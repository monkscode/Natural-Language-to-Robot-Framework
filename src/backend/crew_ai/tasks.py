from crewai import Task

class RobotTasks:
    def plan_steps_task(self, agent, query) -> Task:
        return Task(
            description=f"""
            Analyze the user's query and break it down into a structured series of high-level test steps.
            The user query is: "{query}"

            --- RULES ---
            1.  Respond with a JSON array of objects. Each object represents a single test step.
            2.  Each object must have keys: "step_description", "element_description", "value", and "keyword".
            3.  If the query involves a web search (e.g., "search for X") but does not specify a URL, you MUST generate a first step to open a search engine. Use 'https://www.google.com' as the value for the URL.
            4.  When generating an "Open Browser" step, you MUST also include the `browser=chrome` argument and options to ensure a clean session. Use `options=add_argument("--headless");add_argument("--no-sandbox");add_argument("--incognito")`.
            """,
            expected_output="A JSON array of objects, where each object represents a single test step with the keys: 'step_description', 'element_description', 'value', and 'keyword'.",
            agent=agent,
        )

    def identify_elements_task(self, agent) -> Task:
        return Task(
            description=(
                "For each step provided in the context, you are to act as a world-class expert in web element identification. Your goal is to generate the most reliable, stable, and maintainable locator for the described element.\n\n"
                "The context will be the output of the 'plan_steps_task'.\n\n"
                "--- THE GOLDEN RULE OF LOCATORS ---\n"
                "A good locator is unique, stable, and concise. Always prefer static and unique attributes over dynamic ones. Avoid using attributes that are likely to change, such as `class` attributes that are auto-generated by a framework.\n\n"
                "--- LOCATOR STRATEGY PRIORITY (from best to worst) ---\n"
                "1.  **ID**: `id=element_id` (If a unique and static ID is available, this is always the best choice).\n"
                "2.  **Name**: `name=element_name` (Good for form elements).\n"
                "3.  **CSS Selector**: `css=your_selector` (Powerful and flexible. Use this for most cases where ID or Name are not available).\n"
                "4.  **XPath**: `xpath=//your/xpath` (Use for complex scenarios, like finding elements by their text content or traversing the DOM upwards).\n"
                "5.  **Link Text**: `link=Exact Link Text` (Only for `<a>` tags with unique text).\n\n"
                "--- CSS SELECTOR BEST PRACTICES ---\n"
                "*   **Attribute Selectors:** `css=input[data-testid='submit-button']` (Excellent for custom data attributes).\n"
                "*   **Combining Selectors:** `css=div.main-content > form#login-form input.username` (Be specific but not overly so).\n"
                "*   **Pseudo-classes:** `css=tr:nth-child(3)` (For elements in a list), `css=button:not([disabled])` (For active elements).\n\n"
                "--- XPATH BEST PRACTICES ---\n"
                "*   **Use Relative Paths:** Always start with `//` to avoid breaking tests when the page structure changes.\n"
                "*   **Use `text()` for Visible Text:** `xpath=//button[text()='Log In']` (Very useful for buttons and links).\n"
                "*   **Use `contains()` for Dynamic Text:** `xpath=//span[contains(text(), 'Welcome, ')]` (For text that changes).\n"
                "*   **Use Axes for Traversal:** `xpath=//td[text()='John Doe']/../td[@class='actions']/a[@title='Edit']` (For finding an element relative to another).\n\n"
                "--- HANDLING DYNAMIC & COMPLEX SCENARIOS ---\n"
                "*   **Dynamic IDs/Classes:** If an ID looks like `id='ember123'` or `class='css-a1b2c3d4'`, it's likely dynamic. Avoid it. Look for other attributes or use structural relationships.\n"
                "*   **Iframes:** If an element is inside an iframe, you must first select the iframe itself (e.g., `css=iframe#main-iframe`). The code generation step will handle the `Select Frame` keyword.\n\n"
                "--- FINAL RULES ---\n"
                "1.  You MUST add a 'locator' key to each JSON object in the array.\n"
                "2.  The value of the 'locator' key MUST be a valid Robot Framework locator string (e.g., `id=my-id`, `css=my-selector`).\n"
                "3.  If no specific element is described for a step (e.g., for 'Open Browser'), the locator MUST be an empty string `''`.\n"
                "4.  Analyze the element description carefully and choose the best possible locator based on the priority and best practices."
            ),
            expected_output="A JSON array of objects, where each object represents a single test step with the added 'locator' key, populated with the best possible locator.",
            agent=agent,
        )

    def assemble_code_task(self, agent) -> Task:
        return Task(
            description=(
                "Assemble the final Robot Framework code from the structured steps provided in the context. "
                "The context will be the output of the 'identify_elements_task'.\n\n"
                "--- CRITICAL RULES ---\n"
                "1. You MUST respond with ONLY the raw Robot Framework code.\n"
                "2. The code should start with '*** Settings ***' or '*** Test Cases ***'.\n"
                "3. Do NOT include any introductory text, natural language explanations, or markdown formatting like ``` or ```robotframework."
            ),
            expected_output="A raw string containing only the complete and syntactically correct Robot Framework code. The output MUST NOT contain any markdown fences or other explanatory text.",
            agent=agent,
        )

    def validate_code_task(self, agent) -> Task:
        return Task(
            description=(
                "Validate the generated Robot Framework code for correctness and adherence to critical rules. "
                "The context will be the output of the 'assemble_code_task'.\n\n"
                "--- CRITICAL RULES ---\n"
                "1. You MUST respond with ONLY a single, valid JSON object.\n"
                "2. Do NOT include any introductory text, natural language explanations, or markdown formatting like ```json.\n"
                "3. The JSON object must have exactly two keys: 'valid' (a boolean) and 'reason' (a string).\n"
                "4. If the code is valid, set 'valid' to true and 'reason' to 'The code is valid.'.\n"
                "5. If the code is invalid, set 'valid' to false and provide a brief, clear explanation in the 'reason' key."
            ),
            expected_output="A single, raw JSON object with two keys: 'valid' (boolean) and 'reason' (string). For example: {\"valid\": true, \"reason\": \"The code is valid.\"}",
            agent=agent,
        )
